# MBW.EF.AutoTagger [![Generic Build](https://github.com/LordMike/MBW.EF.AutoTagger/actions/workflows/dotnet.yml/badge.svg)](https://github.com/LordMike/MBW.EF.AutoTagger/actions/workflows/dotnet.yml) [![Nuget](https://img.shields.io/nuget/v/MBW.EF.AutoTagger)](https://www.nuget.org/packages/MBW.EF.AutoTagger)

The AutoTagger library is a utility designed for Entity Framework Core that facilitates the automatic tagging of database queries with their originating call site information. It aims to streamline the process of identifying where queries are generated in the code, aiding in debugging and performance optimization. The library offers configuration options to tailor when query tagging occurs, such as only for certain web requests in ASP.Net.

# Features

* Ability to automatically tag all queries made by an EF dbcontext
  * Functionality to tag with the calling site location of a query
* Conditionally decide if a query should be tagged 

# Nuget packages

| Name | Nuget                                                                                                                    | Note |
|---|--------------------------------------------------------------------------------------------------------------------------|---|
| MBW.EF.AutoTagger | [![Nuget](https://img.shields.io/nuget/v/MBW.EF.AutoTagger)](https://www.nuget.org/packages/MBW.EF.AutoTagger/) | Core functionality |

# Usage Example

The `AutoTagger` library is designed to enhance the observability of Entity Framework Core queries by automatically tagging them with call site information. This enables developers to easily identify the origin of each query, aiding in debugging and performance analysis. The library provides flexibility through configuration options, allowing for detailed control over the tagging behavior.

## Setup

To get started, you need to configure your `DbContext` to use `AutoTagger`. This can be done in the setup of your application, typically in the `Startup.cs` or wherever you configure services. Here's how you can add `AutoTagger` to your project:

```csharp
using Microsoft.EntityFrameworkCore;
using MBW.EF.AutoTagger.Extensions; // Import the namespace for AutoTagger

public class MyDbContext : DbContext
{
    // Your DbContext implementation
}

public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext<MyDbContext>(options =>
    {
        // Configure your DbContext as usual
        options.UseSqlServer("YourConnectionStringHere");
        
        // Enable call site tagging
        options.UseCallsiteTagging(config =>
        {
            // Optional configuration
            config.TaggingMode = CallSiteTaggingMode.OnlyMethod; // Choose tagging mode
            config.TagFilter = query => true; // Define a filter for which queries to tag
        });
    });
}
```

This basic setup automatically tags all queries generated by Entity Framework Core, appending the method name that initiated the query.

## Customizing Tagging Behavior

`AutoTagger` allows for detailed customization to suit different needs. Below is an example demonstrating how to exclude certain calls or include the full stack trace for each query:

```csharp
services.AddDbContext<MyDbContext>(options =>
{
    options.UseSqlServer("YourConnectionStringHere");
    
    // Enable call site tagging with custom settings
    options.UseCallsiteTagging(config =>
    {
        // Include the full stack to the query, excluding internal frames
        config.TaggingMode = CallSiteTaggingMode.FullStackToQuery;
        // Only tag SELECT queries
        // dbContext will also hold a reference to the ServiceProvider so you could pull a service and use that for checks. Be sure not to do any database queries, as that could lead to infinite loops.
        config.TagFilter = (dbContext, dbCommand) => dbCommand.CommandText.StartsWith("SELECT");
        // Exclude system data frames
        config.FrameFilter = assemblyName => !assemblyName.Name.Contains("System.Data");
    });
});
```

This configuration will tag only `SELECT` queries with their call site's full stack trace, excluding any frames internal to Entity Framework and the system data namespace.

By utilizing `AutoTagger`, developers gain valuable insights into their application's database interactions, making it easier to debug and optimize performance.

## Enable tagging conditionally for Miniprofiler
For an ASP.NET Core project that utilizes MiniProfiler for performance profiling, integrating `AutoTagger` to conditionally enable query tagging based on MiniProfiler's state adds a powerful tool for performance optimization. This setup ensures that Entity Framework Core queries are tagged with call site information only when MiniProfiler is active, reducing overhead in production environments while offering detailed insights during development and testing. Below is how you can integrate `AutoTagger` with MiniProfiler in your project:

To set up `AutoTagger` in an ASP.NET Core project with MiniProfiler, first ensure you have MiniProfiler configured correctly in your application. Then, modify your `DbContext` configuration in the `Startup.cs` or wherever you configure your services, to use `AutoTagger` with a custom `TagFilter` that enables tagging only when MiniProfiler is active:

```csharp
using Microsoft.EntityFrameworkCore;
using MBW.EF.AutoTagger.Extensions; // Import AutoTagger extension
using StackExchange.Profiling; // Import MiniProfiler

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // Configure your DbContext
        services.AddDbContext<MyDbContext>(options =>
        {
            options.UseSqlServer("YourConnectionStringHere");

            // Enable call site tagging with a condition based on MiniProfiler's state
            options.UseCallsiteTagging(config =>
            {
                config.TagFilter = (context, command) =>
                {
                    // Check if MiniProfiler is enabled for the current request
                    // MiniProfiler.Current will be null if MP isn't enabled. So other code may enable MP and then we react to it
                    MiniProfiler miniprofiler = MiniProfiler.Current;
                    return miniprofiler != null && !miniprofiler.IsStopped;
                };

                // Optional: configure other aspects of tagging
                config.TaggingMode = CallSiteTaggingMode.OnlyMethod;
            });
        });

        // Additional service configuration...
    }

    // Configure method...
}
```

In this setup, `AutoTagger` leverages the `Miniprofiler.Current` to check if MiniProfiler is currently enabled for the request. This approach provides a seamless integration between MiniProfiler and Entity Framework Core, enabling detailed query analysis without imposing unnecessary overhead on production traffic.

Remember, for this integration to work, MiniProfiler and `AutoTagger` must be correctly set up and configured in your project.